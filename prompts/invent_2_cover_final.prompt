[
  {
    "role": "user",
    "content": [
      {
        "type": "text",
        "text": "Class definition for `Predicate`, `State`, `Type`, `_TypedEntities`, `Object`\n```python\nclass Predicate:\n    \"\"\"Struct defining a predicate (a lifted classifier over states).\"\"\"\n    name: str\n    types: Sequence[Type]\n    # The classifier takes in a complete state and a sequence of objects\n    # representing the arguments. These objects should be the only ones\n    # treated \"specially\" by the classifier.\n    _classifier: Callable[[State, Sequence[Object]],\n                          bool] = field(compare=False)\n\n    def __call__(self, entities: Sequence[_TypedEntity]) -> _Atom:\n        \"\"\"Convenience method for generating Atoms.\"\"\"\n        if self.arity == 0:\n            raise ValueError(\"Cannot use __call__ on a 0-arity predicate, \"\n                             \"since we can't determine whether it becomes a \"\n                             \"LiftedAtom or a GroundAtom. Use the LiftedAtom \"\n                             \"or GroundAtom constructors directly instead\")\n        if all(isinstance(ent, Variable) for ent in entities):\n            return LiftedAtom(self, entities)\n        if all(isinstance(ent, Object) for ent in entities):\n            return GroundAtom(self, entities)\n        raise ValueError(\"Cannot instantiate Atom with mix of \"\n                         \"variables and objects\")\n\n    @cached_property\n    def _hash(self) -> int:\n        return hash(str(self))\n\n    def __hash__(self) -> int:\n        return self._hash\n\n    @cached_property\n    def arity(self) -> int:\n        \"\"\"The arity of this predicate (number of arguments).\"\"\"\n        return len(self.types)\n\n    def holds(self, state: State, objects: Sequence[Object]) -> bool:\n        \"\"\"Public method for calling the classifier.\n\n        Performs type checking first.\n        \"\"\"\n        assert len(objects) == self.arity\n        for obj, pred_type in zip(objects, self.types):\n            assert isinstance(obj, Object)\n            assert obj.is_instance(pred_type)\n        return self._classifier(state, objects)\n\n```\n\n\n```python\nclass State:\n    \"\"\"Struct defining the low-level state of the world.\"\"\"\n    data: Dict[Object, Array]\n    # Some environments will need to store additional simulator state, so\n    # this field is provided.\n    simulator_state: Optional[Any] = None\n\n    def __post_init__(self) -> None:\n        # Check feature vector dimensions.\n        for obj in self:\n            assert len(self[obj]) == obj.type.dim\n\n    def __iter__(self) -> Iterator[Object]:\n        \"\"\"An iterator over the state's objects, in sorted order.\"\"\"\n        return iter(sorted(self.data))\n\n    def __getitem__(self, key: Object) -> Array:\n        return self.data[key]\n\n    def get(self, obj: Object, feature_name: str) -> Any:\n        \"\"\"Look up an object feature by name.\"\"\"\n        idx = obj.type.feature_names.index(feature_name)\n        return self.data[obj][idx]\n\n    def set(self, obj: Object, feature_name: str, feature_val: Any) -> None:\n        \"\"\"Set the value of an object feature by name.\"\"\"\n        idx = obj.type.feature_names.index(feature_name)\n        self.data[obj][idx] = feature_val\n\n    def get_objects(self, object_type: Type) -> List[Object]:\n        \"\"\"Return objects of the given type in the order of __iter__().\"\"\"\n        return [o for o in self if o.is_instance(object_type)]\n\n    def vec(self, objects: Sequence[Object]) -> Array:\n        \"\"\"Concatenated vector of features for each of the objects in the given\n        ordered list.\"\"\"\n        feats: List[Array] = []\n        if len(objects) == 0:\n            return np.zeros(0, dtype=np.float32)\n        for obj in objects:\n            feats.append(self[obj])\n        return np.hstack(feats)\n\n    def copy(self) -> State:\n        \"\"\"Return a copy of this state.\n\n        The simulator state is assumed to be immutable.\n        \"\"\"\n        new_data = {}\n        for obj in self:\n            new_data[obj] = self._copy_state_value(self.data[obj])\n        return State(new_data, simulator_state=self.simulator_state)\n\n    def _copy_state_value(self, val: Any) -> Any:\n        if val is None or isinstance(val, (float, bool, int, str)):\n            return val\n        if isinstance(val, (list, tuple, set)):\n            return type(val)(self._copy_state_value(v) for v in val)\n        assert hasattr(val, \"copy\")\n        return val.copy()\n\n    def allclose(self, other: State) -> bool:\n        \"\"\"Return whether this state is close enough to another one, i.e., its\n        objects are the same, and the features are close.\"\"\"\n        if self.simulator_state is not None or \\\n           other.simulator_state is not None:\n            raise NotImplementedError(\"Cannot use allclose when \"\n                                      \"simulator_state is not None.\")\n        if not sorted(self.data) == sorted(other.data):\n            return False\n        for obj in self.data:\n            if not np.allclose(self.data[obj], other.data[obj], atol=1e-3):\n                return False\n        return True\n\n    def pretty_str(self) -> str:\n        \"\"\"Display the state in a nice human-readable format.\"\"\"\n        type_to_table: Dict[Type, List[List[str]]] = {}\n        for obj in self:\n            if obj.type not in type_to_table:\n                type_to_table[obj.type] = []\n            type_to_table[obj.type].append([obj.name] + \\\n                                            list(map(str, self[obj])))\n        table_strs = []\n        for t in sorted(type_to_table):\n            headers = [\"type: \" + t.name] + list(t.feature_names)\n            table_strs.append(tabulate(type_to_table[t], headers=headers))\n        ll = max(\n            len(line) for table in table_strs for line in table.split(\"\\n\"))\n        prefix = \"#\" * (ll // 2 - 3) + \" STATE \" + \"#\" * (ll - ll // 2 -\n                                                          4) + \"\\n\"\n        suffix = \"\\n\" + \"#\" * ll + \"\\n\"\n        return prefix + \"\\n\\n\".join(table_strs) + suffix\n\n```\n\n\n```python\nclass Type:\n    \"\"\"Struct defining a type.\"\"\"\n    name: str\n    feature_names: Sequence[str] = field(repr=False)\n    parent: Optional[Type] = field(default=None, repr=False)\n\n    @property\n    def dim(self) -> int:\n        \"\"\"Dimensionality of the feature vector of this object type.\"\"\"\n        return len(self.feature_names)\n\n    def __call__(self, name: str) -> _TypedEntity:\n        \"\"\"Convenience method for generating _TypedEntities.\"\"\"\n        if name.startswith(\"?\"):\n            return Variable(name, self)\n        return Object(name, self)\n\n    def __hash__(self) -> int:\n        return hash((self.name, tuple(self.feature_names)))\n\n    def type_str(self) -> str:\n        \"\"\"Get a string representation of the type's name and feature names.\n        \"\"\"\n        features_str = ', '.join(self.feature_names)\n        return f\"Type `{self.name}` has features: {features_str}\"\n\nclass _TypedEntity:\n    \"\"\"Struct defining an entity with some type, either an object (e.g.,\n    block3) or a variable (e.g., ?block).\n\n    Should not be instantiated externally.\n    \"\"\"\n    name: str\n    type: Type\n\n    @cached_property\n    def _str(self) -> str:\n        return f\"{self.name}:{self.type.name}\"\n\n    @cached_property\n    def _hash(self) -> int:\n        return hash(str(self))\n\n    def __str__(self) -> str:\n        return self._str\n\n    def __repr__(self) -> str:\n        return self._str\n\n    def is_instance(self, t: Type) -> bool:\n        \"\"\"Return whether this entity is an instance of the given type, taking\n        hierarchical typing into account.\"\"\"\n        cur_type: Optional[Type] = self.type\n        while cur_type is not None:\n            if cur_type == t:\n                return True\n            cur_type = cur_type.parent\n        return False\n\nclass Object(_TypedEntity):\n    \"\"\"Struct defining an Object, which is just a _TypedEntity whose name does\n    not start with \"?\".\"\"\"\n\n    def __post_init__(self) -> None:\n        assert not self.name.startswith(\"?\")\n\n    def __hash__(self) -> int:\n        # By default, the dataclass generates a new __hash__ method when\n        # frozen=True and eq=True, so we need to override it.\n        return self._hash\n\n```\n\n\nThe object types in the domain are:\n```python\n    # Types\n    # The (x, y) is the center of the robot. Theta is only relevant when\n    # the robot is holding the stick.\n    _robot_type = Type(\"robot\", [\"x\", \"y\", \"theta\"])\n    # The (x, y) is the center of the button.\n    _button_type = Type(\"button\", [\"x\", \"y\", \"pressed\"])\n    # The (x, y) is the bottom left-hand corner of the stick, and theta\n    # is CCW angle in radians, consistent with utils.Rectangle.\n    _stick_type = Type(\"stick\", [\"x\", \"y\", \"theta\", \"held\"])\n    # Holds the stick up so that it can be grasped by the robot.\n    _holder_type = Type(\"holder\", [\"x\", \"y\", \"theta\"])\n```\n\n\nThe existing predicates are:\n{HandEmpty, RobotAboveButton, AboveNoButton, Pressed}\n\nPredicate `HandEmpty` is created by\n```python\nself._HandEmpty = Predicate(\"HandEmpty\", [self._robot_type],\n                                    self._HandEmpty_holds)\n```\nThis creates Predicate (HandEmpty ?x0 - robot) with classifier\n```python\n    def _HandEmpty_holds(self, state: State,\n                         objects: Sequence[Object]) -> bool:\n        robot, = objects\n        stick, = state.get_objects(self._stick_type)\n        return not self._Grasped_holds(state, [robot, stick])\n```\n\nPredicate `RobotAboveButton` is created by\n```python\nself._RobotAboveButton = Predicate(\n            \"RobotAboveButton\", [self._robot_type, self._button_type],\n            self.Above_holds)\n```\nThis creates Predicate (RobotAboveButton ?x0 - robot ?x1 - button) with classifier\n```python\n    @classmethod\n    def Above_holds(cls, state: State, objects: Sequence[Object]) -> bool:\n        \"\"\"Public for use by oracle options.\"\"\"\n        assert len(objects) == 2\n        obj1, obj2 = objects\n        geom1 = cls.object_to_geom(obj1, state)\n        geom2 = cls.object_to_geom(obj2, state)\n        return geom1.intersects(geom2)\n```\n\nPredicate `AboveNoButton` is created by\n```python\nself._AboveNoButton = Predicate(\"AboveNoButton\", [],\n                                        self._AboveNoButton_holds)\n```\nThis creates Predicate (AboveNoButton) with classifier\n```python\n    def _AboveNoButton_holds(self, state: State,\n                             objects: Sequence[Object]) -> bool:\n        assert not objects\n        robot, = state.get_objects(self._robot_type)\n        stick, = state.get_objects(self._stick_type)\n        for button in state.get_objects(self._button_type):\n            if self.Above_holds(state, [robot, button]):\n                return False\n            if self.Above_holds(state, [stick, button]):\n                return False\n        return True\n```\n\nPredicate `Pressed` is created by\n```python\nself._Pressed = Predicate(\"Pressed\", [self._button_type],\n                                  self._Pressed_holds)\n```\nThis creates Predicate (Pressed ?x0 - button) with classifier\n```python\n    @staticmethod\n    def _Pressed_holds(state: State, objects: Sequence[Object]) -> bool:\n        button, = objects\n        return state.get(button, \"pressed\") > 0.5\n```\n\n\nThe existing abstract action operators with options are:\nNSRT-RobotPressButtonFromButton:\n    Parameters: [?robot:robot, ?button:button, ?from_button:button, ?stick:stick]\n    Preconditions: [HandEmpty(?robot:robot), RobotAboveButton(?robot:robot, ?from_button:button)]\n    Add Effects: [Pressed(?button:button), RobotAboveButton(?robot:robot, ?button:button)]\n    Delete Effects: [RobotAboveButton(?robot:robot, ?from_button:button)]\n    Ignore Effects: []\n    Option Spec: RobotPressButton(?robot:robot, ?button:button, ?stick:stick)\nNSRT-RobotPressButtonFromNothing:\n    Parameters: [?robot:robot, ?button:button, ?stick:stick]\n    Preconditions: [AboveNoButton(), HandEmpty(?robot:robot)]\n    Add Effects: [Pressed(?button:button), RobotAboveButton(?robot:robot, ?button:button)]\n    Delete Effects: [AboveNoButton()]\n    Ignore Effects: []\n    Option Spec: RobotPressButton(?robot:robot, ?button:button, ?stick:stick)\n\n\nThe agents has attempted the following tasks and got the following results:\n\nTask 0:\nInitial State:\n{button0:button: array([4.53936662, 1.19547267, 0.        ]), robby:robot: array([7.24267984, 2.35137922, 1.57079633]), stick:stick: array([1.33057422, 0.90430819, 1.57079633, 0.        ]), holder:holder: array([1.36807422, 2.03720302, 1.57079633])}\nInitial Abstract State:\n{AboveNoButton(), HandEmpty(robby:robot)}\n\nTask goal:\n{Pressed(button0:button)}\n\nThe bilevel planning succeeded.\nThe state-action trajectory is:\n\nState: \n{button0:button: array([4.53936662, 1.19547267, 0.        ]), holder:holder: array([1.36807422, 2.03720302, 1.57079633]), robby:robot: array([7.24267984, 2.35137922, 1.57079633]), stick:stick: array([1.33057422, 0.90430819, 1.57079633, 0.        ])}\n\nAction: [-1. -1.  0. -1.]\n\nState: \n{button0:button: array([4.53936662, 1.19547267, 0.        ]), holder:holder: array([1.36807422, 2.03720302, 1.57079633]), robby:robot: array([6.74267984, 1.85137922, 1.57079633]), stick:stick: array([1.33057422, 0.90430819, 1.57079633, 0.        ])}\n\nAction: [-1. -1.  0. -1.]\n\nState: \n{button0:button: array([4.53936662, 1.19547267, 0.        ]), holder:holder: array([1.36807422, 2.03720302, 1.57079633]), robby:robot: array([6.24267984, 1.35137922, 1.57079633]), stick:stick: array([1.33057422, 0.90430819, 1.57079633, 0.        ])}\n\nAction: [-1.        -0.3118131  0.        -1.       ]\n\nState: \n{button0:button: array([4.53936662, 1.19547267, 0.        ]), holder:holder: array([1.36807422, 2.03720302, 1.57079633]), robby:robot: array([5.74267984, 1.19547268, 1.57079633]), stick:stick: array([1.33057422, 0.90430819, 1.57079633, 0.        ])}\n\nAction: [-1.0000000e+00 -1.2342516e-08  0.0000000e+00 -1.0000000e+00]\n\nState: \n{button0:button: array([4.53936662, 1.19547267, 0.        ]), holder:holder: array([1.36807422, 2.03720302, 1.57079633]), robby:robot: array([5.24267984, 1.19547267, 1.57079633]), stick:stick: array([1.33057422, 0.90430819, 1.57079633, 0.        ])}\n\nAction: [-1.  0.  0. -1.]\n\nState: \n{button0:button: array([4.53936662, 1.19547267, 0.        ]), holder:holder: array([1.36807422, 2.03720302, 1.57079633]), robby:robot: array([4.74267984, 1.19547267, 1.57079633]), stick:stick: array([1.33057422, 0.90430819, 1.57079633, 0.        ])}\n\nAction: [-0.40662643  0.          0.         -1.        ]\n\nState: \n{button0:button: array([4.53936662, 1.19547267, 0.        ]), holder:holder: array([1.36807422, 2.03720302, 1.57079633]), robby:robot: array([4.53936662, 1.19547267, 1.57079633]), stick:stick: array([1.33057422, 0.90430819, 1.57079633, 0.        ])}\n\nAction: [0. 0. 0. 1.]\n\nState: \n{button0:button: array([4.53936662, 1.19547267, 1.        ]), holder:holder: array([1.36807422, 2.03720302, 1.57079633]), robby:robot: array([4.53936662, 1.19547267, 1.57079633]), stick:stick: array([1.33057422, 0.90430819, 1.57079633, 0.        ])}\n\n\nTask 1:\nInitial State:\n{button0:button: array([4.12959885, 5.31645591, 0.        ]), robby:robot: array([2.68312242, 1.60325254, 1.57079633]), stick:stick: array([5.2335857 , 0.91939085, 1.57079633, 0.        ]), holder:holder: array([5.2710857 , 1.0552689 , 1.57079633])}\nInitial Abstract State:\n{AboveNoButton(), HandEmpty(robby:robot)}\n\nTask goal:\n{Pressed(button0:button)}\n\nTask 2:\nInitial State:\n{button0:button: array([3.57696323, 4.4755098 , 0.        ]), robby:robot: array([3.80648511, 0.91743119, 1.57079633]), stick:stick: array([7.44376485, 1.28201118, 1.57079633, 0.        ]), holder:holder: array([7.48126485, 1.50370242, 1.57079633])}\nInitial Abstract State:\n{AboveNoButton(), HandEmpty(robby:robot)}\n\nTask goal:\n{Pressed(button0:button)}\n\nTask 3:\nInitial State:\n{button0:button: array([0.68039638, 5.05992364, 0.        ]), button1:button: array([6.17380502, 3.03278716, 0.        ]), robby:robot: array([5.08101831, 1.2766754 , 1.57079633]), stick:stick: array([9.12765454, 0.95459471, 1.57079633, 0.        ]), holder:holder: array([9.16515454, 2.03629715, 1.57079633])}\nInitial Abstract State:\n{AboveNoButton(), HandEmpty(robby:robot)}\n\nTask goal:\n{Pressed(button0:button), Pressed(button1:button)}\n\nTask 4:\nInitial State:\n{button0:button: array([3.97218845, 4.0131027 , 0.        ]), robby:robot: array([0.80389501, 2.32495605, 1.57079633]), stick:stick: array([7.27363051, 0.86147364, 1.57079633, 0.        ]), holder:holder: array([7.31113051, 1.37455396, 1.57079633])}\nInitial Abstract State:\n{AboveNoButton(), HandEmpty(robby:robot)}\n\nTask goal:\n{Pressed(button0:button)}\n\n\n\n\nYour task: define new predicates in the format of\n```\n[predicate_variable] = Predicate(name: Str, \n                        types: Sequence[Type], \n                        _classifier: Callable[[State, Sequence[Object]], bool])\n```\nwhere [predicate_variable] is replaced with the actual name\nto make the planning more effective and efficient (e.g., stops fast when the goals are not reachable).\nNote that new action operators (NSRTs, with preconditions and effects) and options can be learned from predicates, and make sure the invented predicates they don't require extra constants."
      }
    ]
  }
]