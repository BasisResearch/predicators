You are an expert roboticist and AI researcher tasked with inventing task-specific state abstraction predicates for effective and efficient robotic planning.

Class definitions for `Predicate` and `State` are:
```python
class Predicate:
    """
    A class representing a predicate (a lifted classifier over states) in the 
    context of AI task planning.
    A predicate is mainly a function that describes a property or characteristic 
    of states. The function takes a state and a sequence of objects as input, 
    and returns a boolean value indicating whether the property holds for those 
    objects in that state.

    Attributes:
    -----------
    name : str
        The name of the predicate.

    types : Sequence[Type]
        The types of the objects that the predicate applies to. This sequence 
        should have the same length as the sequence of objects passed to the 
        classifier.

    _classifier : Callable[[State, Sequence[Object]], bool]
        The classifier function for the predicate. This function takes a state 
        and a sequence of objects as input, and returns a boolean value. The 
        objects in the sequence should correspond one-to-one with the types in 
        the 'types' attribute. The classifier should return True if the 
        predicate holds for those objects in that state, and False otherwise.
    """    
    name: str
    types: Sequence[Type]
    # The classifier takes in a complete state and a sequence of objects
    # representing the arguments. These objects should be the only ones
    # treated "specially" by the classifier.
    _classifier: Callable[[State, Sequence[Object]], bool]

class State:
    """
    A class representing the low-level state of the world.

    Attributes:
    -----------
    data : Dict[Object, Array]
        A dictionary mapping objects to their feature vectors. The feature vectors are numpy arrays.

    simulator_state : Optional[Any]
        Some environments may need to store additional simulator state. This field is provided for that purpose. It is optional and defaults to None.

    Methods:
    --------
    get(self, obj: Object, feature_name: str) -> Any:
        This method looks up an object feature by name. It returns the value of 
        the feature.

    get_objects(self, object_type: Type) -> List[Object]:
        This method returns objects of the given type in the order of 
        __iter__().
    """
    data: Dict[Object, Array]
    # Some environments will need to store additional simulator state, so
    # this field is provided.
    simulator_state: Optional[Any] = None

    def get(self, obj: Object, feature_name: str) -> Any:
        """
        Look up an object feature by name.

        Parameters:
        -----------
        obj : Object
            The object whose feature value is to be retrieved.
        feature_name : str
            The name of the feature to be retrieved.

        Returns:
        --------
        Any
            The value of the specified feature for the given object.

        Raises:
        -------
        ValueError
            If the specified feature name is not found in the object's type feature names.
        
        Examples:
        ---------
        >>> # An example for predicate Covers
        >>> _block_type = Type("block", ["is_block", "is_target", "width", 
                "pose", "grasp"])
        >>> _target_type = Type("target", ["is_block", "is_target", "width", 
                "pose"])
        >>> block1 = Object("block1", _block_type)
        >>> target1 = Object("target1", _target_type)
        >>> state = State({
                block1: np.array([1.0, 0.0, 0.1, 0.2, -1.0]), 
                target1: np.array([0.0, 1.0, 0.05, 0.4])})
        >>> def _Covers_holds(state: State, objects: Sequence[Object]) -> 
                    bool:
        >>>     block, target = objects
        >>>     block_pose = state.get(block, "pose")
        >>>     block_width = state.get(block, "width")
        >>>     target_pose = state.get(target, "pose")
        >>>     target_width = state.get(target, "width")
        >>>     return (block_pose-block_width/2 <= \
                        target_pose-target_width/2) and \
                        (block_pose+block_width/2 >= \
                        target_pose+target_width/2) and \
                        state.get(block, "grasp") == -1
        >>> _Covers = Predicate("Covers", [_block_type, _target_type],
                        _Covers_holds)

        >>> # Another example for predicate On
        >>> _block_type = Type("block", ["pose_x", "pose_y", "pose_z", 
                            "held", "color_r", "color_g", "color_b"])
        >>> block1 = Object("block1", _block_type)
        >>> block2 = Object("block2", _block_type)
        >>> state = State({
                block1: np.array([1.0, 3.0, 0.2, 0.0, 1.0, 0.0, 0.0]),
                block2: np.array([2.0, 3.0, 0.3, 0.0, 0.0, 1.0, 0.0])})
        >>> on_tol = 0.01
        >>> def _On_holds(self, state: State, objects: Sequence[Object]) ->\ 
                bool:
        >>>     block1, block2 = objects
        >>>     if state.get(block1, "held") >= self.held_tol or \
        >>>        state.get(block2, "held") >= self.held_tol:
        >>>         return False
        >>>     x1 = state.get(block1, "pose_x")
        >>>     y1 = state.get(block1, "pose_y")
        >>>     z1 = state.get(block1, "pose_z")
        >>>     x2 = state.get(block2, "pose_x")
        >>>     y2 = state.get(block2, "pose_y")
        >>>     z2 = state.get(block2, "pose_z")
        >>>     return np.allclose([x1, y1, z1], 
                        [x2, y2, z2 + self._block_size],
                        atol=on_tol)
        >>> _On = Predicate("On", [_block_type, _block_type],
                            _On_holds)
        """

    def get_objects(self, object_type: Type) -> List[Object]:
        """
        Return objects of the given type in the order of __iter__().

        Parameters:
        -----------
        object_type : Type
            The type of the objects to be retrieved.

        Returns:
        --------
        List[Object]
            A list of objects of the specified type, in the order they are 
            iterated over in the state.

        Examples:
        ---------
        >>> _robot_type = Type("robot",
                                ["x", "y", "z", "tilt", "wrist", "fingers"])
        >>> _cup_type = Type("cup",
            ["x", "y", "capacity_liquid", "target_liquid", "current_liquid"])
        >>> robot = Object("robby", _robot_type)
        >>> cup1 = Object("cup1", _cup_type)
        >>> cup2 = Object("cup2", _cup_type)
        >>> state = State({
                        robot: np.array([5.0, 5.0, 10.0, 0.0, 0.0, 0.4]),
                        cup1: np.array([3.0, 2.0, 1.0, 0.75, 0.0]),
                        cup2: np.array([5.0, 6.0, 1.5, 1.125, 0.0])})
        >>> def _NotAboveCup_holds(state: State,
        >>>                        objects: Sequence[Object]) -> bool:
        >>>     robot, jug = objects
        >>>     for cup in state.get_objects(_cup_type):
        >>>         if _robot_jug_above_cup(state, cup):
        >>>             return False
        >>>     return True
        >>> _NotAboveCup = Predicate("NotAboveCup", [_robot_type, _jug_type],
                                    _NotAboveCup_holds)

        """
```


The environment includes the following object-type variables:
```python
# Types
# The (x, y) is the center of the button.
_button_type = Type(name="button", feature_names=["x", "y", "pressed"])
# Holds the stick up so that it can be grasped by the robot.
_holder_type = Type(name="holder", feature_names=["x", "y", "theta"])
# The (x, y) is the bottom left-hand corner of the stick, and theta
# is CCW angle in radians, consistent with utils.Rectangle. The tip
# x and y correspond to the end of the stick.
_stick_type = Type("stick", ["x", "y", "tip_x", "tip_y", "theta", "held"])
# The (x, y) is the center of the center. Theta is only relevant when
# the hand is holding the stick.
# We add an attribute for the open/closed status of the robot's gripper.
_hand_type = Type("hand", ["x", "y", "theta", "fingers"])
```


The initial set of predicates used to describe goals includes:
{'Pressed(?x)'}

Predicate Pressed(?x) is defined by
```python
def _Pressed_holds(state: State, objects: Sequence[Object]) -> bool:
    button, = objects
    return state.get(button, "pressed") > 0.5
_Pressed = Predicate("Pressed", [_button_type],
                                    _Pressed_holds)
```


The set of parameterized options includes:
HandMoveToButton(?hand:hand, ?to:button)
PickStick(?hand:hand, ?stick:stick)
StickMoveToButton(?hand:hand, ?to:button, ?stick:stick)
HandMoveToButton(?hand:hand, ?button:button)
PlaceStick(?hand:hand, ?stick:stick, ?holder:holder)
HandPressButton(?hand:hand, ?button:button)
StickPressButton(?hand:hand, ?stick:stick, ?button:button)

The existing abstract action operators utilizing these options are:
HandMoveToButtonFromNothing:
    Parameters: [?hand:hand, ?button:button]
    Preconditions: []
    Add Effects: []
    Delete Effects: []
    Ignore Effects: []
    Option Spec: HandMoveToButton(?hand:hand, ?button:button)
HandMoveToButtonFromButton:
    Parameters: [?hand:hand, ?from:button, ?to:button]
    Preconditions: []
    Add Effects: []
    Delete Effects: []
    Ignore Effects: []
    Option Spec: HandMoveToButton(?hand:hand, ?to:button)
PlaceStickFromButton:
    Parameters: [?hand:hand, ?stick:stick, ?holder:holder, ?from_button:button]
    Preconditions: []
    Add Effects: []
    Delete Effects: []
    Ignore Effects: []
    Option Spec: PlaceStick(?hand:hand, ?stick:stick, ?holder:holder)
StickMoveToButtonFromButton:
    Parameters: [?hand:hand, ?stick:stick, ?to:button, ?from:button]
    Preconditions: []
    Add Effects: []
    Delete Effects: []
    Ignore Effects: []
    Option Spec: StickMoveToButton(?hand:hand, ?to:button, ?stick:stick)
PickStickFromNothing:
    Parameters: [?hand:hand, ?stick:stick]
    Preconditions: []
    Add Effects: []
    Delete Effects: []
    Ignore Effects: []
    Option Spec: PickStick(?hand:hand, ?stick:stick)
StickMoveToButtonFromNothing:
    Parameters: [?hand:hand, ?stick:stick, ?to:button]
    Preconditions: []
    Add Effects: []
    Delete Effects: []
    Ignore Effects: []
    Option Spec: StickMoveToButton(?hand:hand, ?to:button, ?stick:stick)
PickStickFromButton:
    Parameters: [?hand:hand, ?stick:stick, ?from_button:button]
    Preconditions: []
    Add Effects: []
    Delete Effects: []
    Ignore Effects: []
    Option Spec: PickStick(?hand:hand, ?stick:stick)
PlaceStickFromNothing:
    Parameters: [?hand:hand, ?stick:stick, ?holder:holder]
    Preconditions: []
    Add Effects: []
    Delete Effects: []
    Ignore Effects: []
    Option Spec: PlaceStick(?hand:hand, ?stick:stick, ?holder:holder)
HandPressButton:
    Parameters: [?hand:hand, ?button:button]
    Preconditions: []
    Add Effects: [Pressed(?button:button)]
    Delete Effects: []
    Ignore Effects: []
    Option Spec: HandPressButton(?hand:hand, ?button:button)
StickPressButton:
    Parameters: [?hand:hand, ?stick:stick, ?button:button]
    Preconditions: []
    Add Effects: [Pressed(?button:button)]
    Delete Effects: []
    Ignore Effects: []
    Option Spec: StickPressButton(?hand:hand, ?stick:stick, ?button:button)

The agent attempted the training tasks by bilevel planning (first plan with the ground action operators then execute its corresponding ground options), collecting these results:
Ground option PickStick(robby_hand:hand, stick:stick) was applied on 129 states and *successfully* executed on 123/129 states (ground truth positive states).
  Out of the 123 GT positive states, with the current predicates and operators, 123/123 states *satisfy* at least one of its operators' precondition (true positives), to list 3:
  {'button0:button': {'x': 2.5, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 3.2, 'y': 1.1, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.7, 'y': 1.6, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 3.1, 'y': 0.9, 'tip_x': 3.1, 'tip_y': 3.9, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 4.8, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 2.9, 'y': 1.9, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.5, 'y': 1.0, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 2.9, 'y': 0.8, 'tip_x': 2.9, 'tip_y': 3.8, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 3.9, 'y': 4.9, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 5.3, 'y': 2.4, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 0.8, 'tip_x': 0.7, 'tip_y': 3.8, 'theta': 1.6, 'held': 0.0}}

Ground option PickStick(robby_hand:hand, stick:stick) was applied on 129 states and *failed* to executed on 6/129 states (ground truth negative states).
  Out of the 6 GT negative states, with the current predicates and operators, 6/6 states *satisfy* at least one of its operators' precondition (false positives):
  {'button0:button': {'x': 4.8, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 2.9, 'y': 1.9, 'theta': 1.6},
   'robby_hand:hand': {'x': 2.8, 'y': 1.5, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 2.9, 'y': 1.3, 'tip_x': 2.9, 'tip_y': 4.3, 'theta': 1.6, 'held': 1.0}}

  {'button0:button': {'x': 3.1, 'y': 3.9, 'pressed': 0.0},
   'holder:holder': {'x': 1.5, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.4, 'y': 2.7, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 1.4, 'y': 1.2, 'tip_x': 1.4, 'tip_y': 4.1, 'theta': 1.6, 'held': 1.0}}

  {'button0:button': {'x': 2.5, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 3.2, 'y': 1.1, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.1, 'y': 2.3, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 3.1, 'y': 0.4, 'tip_x': 3.1, 'tip_y': 3.4, 'theta': 1.6, 'held': 1.0}}

Ground option StickMoveToButton(robby_hand:hand, button0:button, stick:stick) was applied on 126 states and *successfully* executed on 8/126 states (ground truth positive states).
  Out of the 8 GT positive states, with the current predicates and operators, 8/8 states *satisfy* at least one of its operators' precondition (true positives), to list 3:
  {'button0:button': {'x': 4.9, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 4.7, 'y': 1.2, 'theta': 1.6},
   'robby_hand:hand': {'x': 4.7, 'y': 1.1, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 4.7, 'y': 0.7, 'tip_x': 4.7, 'tip_y': 3.7, 'theta': 1.6, 'held': 1.0}}

  {'button0:button': {'x': 3.1, 'y': 3.9, 'pressed': 0.0},
   'holder:holder': {'x': 1.5, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.5, 'y': 2.5, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 1.5, 'y': 0.9, 'tip_x': 1.5, 'tip_y': 3.8, 'theta': 1.6, 'held': 1.0}}

  {'button0:button': {'x': 3.9, 'y': 4.9, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 0.6, 'y': 1.6, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 0.7, 'y': 0.8, 'tip_x': 0.7, 'tip_y': 3.8, 'theta': 1.6, 'held': 1.0}}

Ground option StickMoveToButton(robby_hand:hand, button0:button, stick:stick) was applied on 126 states and *failed* to executed on 118/126 states (ground truth negative states).
  Out of the 118 GT negative states, with the current predicates and operators, 118/118 states *satisfy* at least one of its operators' precondition (false positives), to list 3:
  {'button0:button': {'x': 3.0, 'y': 5.2, 'pressed': 0.0},
   'holder:holder': {'x': 1.7, 'y': 0.7, 'theta': 1.6},
   'robby_hand:hand': {'x': 4.2, 'y': 2.5, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 1.7, 'y': 0.8, 'tip_x': 1.7, 'tip_y': 3.8, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 4.8, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 2.9, 'y': 1.9, 'theta': 1.6},
   'robby_hand:hand': {'x': 5.0, 'y': 2.5, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 2.9, 'y': 0.8, 'tip_x': 2.9, 'tip_y': 3.8, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 3.9, 'y': 4.9, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 5.8, 'y': 2.9, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 0.8, 'tip_x': 0.7, 'tip_y': 3.8, 'theta': 1.6, 'held': 0.0}}

Ground option StickMoveToButton(robby_hand:hand, button1:button, stick:stick) was applied on 41 states and *failed* to executed on 41/41 states (ground truth negative states).
  Out of the 41 GT negative states, with the current predicates and operators, 41/41 states *satisfy* at least one of its operators' precondition (false positives):
  {'button0:button': {'x': 3.8, 'y': 1.1, 'pressed': 0.0},
   'button1:button': {'x': 1.7, 'y': 1.2, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 2.7, 'y': 0.2, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 1.1, 'tip_x': 0.7, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 3.8, 'y': 1.1, 'pressed': 0.0},
   'button1:button': {'x': 1.7, 'y': 1.2, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 5.5, 'y': 1.5, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 1.1, 'tip_x': 0.7, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}

Ground option HandPressButton(robby_hand:hand, button1:button) was applied on 104 states and *successfully* executed on 11/104 states (ground truth positive states).
  Out of the 11 GT positive states, with the current predicates and operators, 11/11 states *satisfy* at least one of its operators' precondition (true positives), to list 3:
  {'button0:button': {'x': 4.9, 'y': 5.1, 'pressed': 0.0},
   'button1:button': {'x': 3.0, 'y': 0.9, 'pressed': 0.0},
   'holder:holder': {'x': 2.2, 'y': 1.8, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.3, 'y': 2.0, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 2.2, 'y': 1.4, 'tip_x': 2.2, 'tip_y': 4.3, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 3.8, 'y': 1.1, 'pressed': 0.0},
   'button1:button': {'x': 1.7, 'y': 1.2, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.7, 'y': 1.2, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 1.1, 'tip_x': 0.7, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 0.7, 'y': 5.2, 'pressed': 0.0},
   'button1:button': {'x': 4.2, 'y': 1.9, 'pressed': 0.0},
   'holder:holder': {'x': 2.0, 'y': 2.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 2.8, 'y': 1.8, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 1.9, 'y': 1.0, 'tip_x': 1.9, 'tip_y': 3.9, 'theta': 1.6, 'held': 0.0}}

Ground option HandPressButton(robby_hand:hand, button1:button) was applied on 104 states and *failed* to executed on 93/104 states (ground truth negative states).
  Out of the 93 GT negative states, with the current predicates and operators, 93/93 states *satisfy* at least one of its operators' precondition (false positives), to list 3:
  {'button0:button': {'x': 3.8, 'y': 1.1, 'pressed': 1.0},
   'button1:button': {'x': 1.7, 'y': 1.2, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.8, 'y': 1.1, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 1.1, 'tip_x': 0.7, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 0.7, 'y': 5.2, 'pressed': 0.0},
   'button1:button': {'x': 4.2, 'y': 1.9, 'pressed': 0.0},
   'holder:holder': {'x': 2.0, 'y': 2.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 2.8, 'y': 1.8, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 1.9, 'y': 1.0, 'tip_x': 1.9, 'tip_y': 3.9, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 4.9, 'y': 5.1, 'pressed': 0.0},
   'button1:button': {'x': 3.0, 'y': 0.9, 'pressed': 0.0},
   'holder:holder': {'x': 2.2, 'y': 1.8, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.3, 'y': 2.0, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 2.2, 'y': 1.4, 'tip_x': 2.2, 'tip_y': 4.3, 'theta': 1.6, 'held': 0.0}}

Ground option HandMoveToButton(robby_hand:hand, button1:button) was applied on 42 states and *successfully* executed on 42/42 states (ground truth positive states).
Ground option PlaceStick(robby_hand:hand, stick:stick, holder:holder) was applied on 129 states and *successfully* executed on 14/129 states (ground truth positive states).
  Out of the 14 GT positive states, with the current predicates and operators, 14/14 states *satisfy* at least one of its operators' precondition (true positives), to list 3:
  {'button0:button': {'x': 4.9, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 4.7, 'y': 1.2, 'theta': 1.6},
   'robby_hand:hand': {'x': 4.7, 'y': 1.1, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 4.7, 'y': 0.7, 'tip_x': 4.7, 'tip_y': 3.7, 'theta': 1.6, 'held': 1.0}}

  {'button0:button': {'x': 2.5, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 3.2, 'y': 1.1, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.1, 'y': 2.8, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 3.1, 'y': 0.9, 'tip_x': 3.1, 'tip_y': 3.9, 'theta': 1.6, 'held': 1.0}}

  {'button0:button': {'x': 3.1, 'y': 3.9, 'pressed': 0.0},
   'holder:holder': {'x': 1.5, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.5, 'y': 2.5, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 1.5, 'y': 0.9, 'tip_x': 1.5, 'tip_y': 3.8, 'theta': 1.6, 'held': 1.0}}

Ground option PlaceStick(robby_hand:hand, stick:stick, holder:holder) was applied on 129 states and *failed* to executed on 115/129 states (ground truth negative states).
  Out of the 115 GT negative states, with the current predicates and operators, 115/115 states *satisfy* at least one of its operators' precondition (false positives), to list 3:
  {'button0:button': {'x': 3.9, 'y': 4.9, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 4.8, 'y': 1.9, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 0.8, 'tip_x': 0.7, 'tip_y': 3.8, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 4.8, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 2.9, 'y': 1.9, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.0, 'y': 0.6, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 2.9, 'y': 0.8, 'tip_x': 2.9, 'tip_y': 3.8, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 3.1, 'y': 3.9, 'pressed': 0.0},
   'holder:holder': {'x': 1.5, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.0, 'y': 1.8, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 1.5, 'y': 0.9, 'tip_x': 1.5, 'tip_y': 3.8, 'theta': 1.6, 'held': 0.0}}

Ground option HandPressButton(robby_hand:hand, button0:button) was applied on 158 states and *successfully* executed on 27/158 states (ground truth positive states).
  Out of the 27 GT positive states, with the current predicates and operators, 27/27 states *satisfy* at least one of its operators' precondition (true positives), to list 3:
  {'button0:button': {'x': 4.9, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 4.7, 'y': 1.2, 'theta': 1.6},
   'robby_hand:hand': {'x': 4.8, 'y': 2.6, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 4.9, 'y': 2.2, 'tip_x': 4.9, 'tip_y': 5.2, 'theta': 1.6, 'held': 1.0}}

  {'button0:button': {'x': 3.8, 'y': 1.1, 'pressed': 0.0},
   'button1:button': {'x': 1.7, 'y': 1.2, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.8, 'y': 1.1, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 1.1, 'tip_x': 0.7, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 5.0, 'y': 1.6, 'pressed': 0.0},
   'holder:holder': {'x': 3.0, 'y': 1.1, 'theta': 1.6},
   'robby_hand:hand': {'x': 5.0, 'y': 1.6, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 3.0, 'y': 1.4, 'tip_x': 3.0, 'tip_y': 4.3, 'theta': 1.6, 'held': 0.0}}

Ground option HandPressButton(robby_hand:hand, button0:button) was applied on 158 states and *failed* to executed on 131/158 states (ground truth negative states).
  Out of the 131 GT negative states, with the current predicates and operators, 131/131 states *satisfy* at least one of its operators' precondition (false positives), to list 3:
  {'button0:button': {'x': 3.8, 'y': 1.1, 'pressed': 0.0},
   'button1:button': {'x': 1.7, 'y': 1.2, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.7, 'y': 1.2, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 1.1, 'tip_x': 0.7, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 4.9, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 4.7, 'y': 1.2, 'theta': 1.6},
   'robby_hand:hand': {'x': 4.7, 'y': 1.1, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 4.7, 'y': 0.7, 'tip_x': 4.7, 'tip_y': 3.7, 'theta': 1.6, 'held': 1.0}}

  {'button0:button': {'x': 0.8, 'y': 2.1, 'pressed': 0.0},
   'holder:holder': {'x': 3.9, 'y': 1.2, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.1, 'y': 1.7, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 3.9, 'y': 1.5, 'tip_x': 3.9, 'tip_y': 4.4, 'theta': 1.6, 'held': 0.0}}

Ground option StickPressButton(robby_hand:hand, stick:stick, button0:button) was applied on 158 states and *successfully* executed on 7/158 states (ground truth positive states).
  Out of the 7 GT positive states, with the current predicates and operators, 7/7 states *satisfy* at least one of its operators' precondition (true positives), to list 3:
  {'button0:button': {'x': 1.9, 'y': 4.1, 'pressed': 0.0},
   'button1:button': {'x': 4.0, 'y': 4.8, 'pressed': 0.0},
   'holder:holder': {'x': 1.2, 'y': 0.8, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.8, 'y': 1.3, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 1.1, 'y': 0.7, 'tip_x': 1.1, 'tip_y': 3.6, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 2.2, 'y': 3.7, 'pressed': 0.0},
   'holder:holder': {'x': 3.5, 'y': 2.6, 'theta': 1.6},
   'robby_hand:hand': {'x': 2.2, 'y': 1.7, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 2.2, 'y': 0.7, 'tip_x': 2.2, 'tip_y': 3.7, 'theta': 1.6, 'held': 1.0}}

  {'button0:button': {'x': 3.1, 'y': 3.9, 'pressed': 0.0},
   'holder:holder': {'x': 1.5, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.1, 'y': 2.6, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 3.1, 'y': 1.0, 'tip_x': 3.1, 'tip_y': 3.9, 'theta': 1.6, 'held': 1.0}}

Ground option StickPressButton(robby_hand:hand, stick:stick, button0:button) was applied on 158 states and *failed* to executed on 151/158 states (ground truth negative states).
  Out of the 151 GT negative states, with the current predicates and operators, 151/151 states *satisfy* at least one of its operators' precondition (false positives), to list 3:
  {'button0:button': {'x': 3.8, 'y': 1.1, 'pressed': 0.0},
   'button1:button': {'x': 1.7, 'y': 1.2, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.7, 'y': 1.2, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 1.1, 'tip_x': 0.7, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 4.9, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 4.7, 'y': 1.2, 'theta': 1.6},
   'robby_hand:hand': {'x': 4.7, 'y': 1.1, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 4.7, 'y': 0.7, 'tip_x': 4.7, 'tip_y': 3.7, 'theta': 1.6, 'held': 1.0}}

  {'button0:button': {'x': 1.9, 'y': 4.1, 'pressed': 0.0},
   'button1:button': {'x': 4.0, 'y': 4.8, 'pressed': 0.0},
   'holder:holder': {'x': 1.2, 'y': 0.8, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.8, 'y': 1.3, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 1.1, 'y': 0.7, 'tip_x': 1.1, 'tip_y': 3.6, 'theta': 1.6, 'held': 0.0}}

Ground option HandMoveToButton(robby_hand:hand, button0:button) was applied on 131 states and *successfully* executed on 53/131 states (ground truth positive states).
  Out of the 53 GT positive states, with the current predicates and operators, 53/53 states *satisfy* at least one of its operators' precondition (true positives), to list 3:
  {'button0:button': {'x': 0.8, 'y': 2.1, 'pressed': 0.0},
   'holder:holder': {'x': 3.9, 'y': 1.2, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.1, 'y': 1.7, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 3.9, 'y': 1.5, 'tip_x': 3.9, 'tip_y': 4.4, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 4.7, 'y': 2.1, 'pressed': 0.0},
   'holder:holder': {'x': 1.4, 'y': 1.1, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.4, 'y': 1.0, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 1.4, 'y': 1.0, 'tip_x': 1.4, 'tip_y': 4.0, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 0.8, 'y': 2.3, 'pressed': 0.0},
   'holder:holder': {'x': 4.2, 'y': 2.2, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.3, 'y': 1.1, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 4.2, 'y': 1.1, 'tip_x': 4.2, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}

Ground option HandMoveToButton(robby_hand:hand, button0:button) was applied on 131 states and *failed* to executed on 78/131 states (ground truth negative states).
  Out of the 78 GT negative states, with the current predicates and operators, 78/78 states *satisfy* at least one of its operators' precondition (false positives), to list 3:
  {'button0:button': {'x': 3.1, 'y': 3.9, 'pressed': 0.0},
   'holder:holder': {'x': 1.5, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.1, 'y': 2.8, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 1.5, 'y': 0.9, 'tip_x': 1.5, 'tip_y': 3.8, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 4.8, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 2.9, 'y': 1.9, 'theta': 1.6},
   'robby_hand:hand': {'x': 4.3, 'y': 2.5, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 4.4, 'y': 2.3, 'tip_x': 4.4, 'tip_y': 5.3, 'theta': 1.6, 'held': 1.0}}

  {'button0:button': {'x': 3.1, 'y': 3.9, 'pressed': 0.0},
   'holder:holder': {'x': 1.5, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.5, 'y': 2.5, 'theta': 1.6, 'fingers': 0.0},
   'stick:stick': {'x': 1.5, 'y': 0.9, 'tip_x': 1.5, 'tip_y': 3.8, 'theta': 1.6, 'held': 1.0}}

Ground option StickPressButton(robby_hand:hand, stick:stick, button1:button) was applied on 98 states and *successfully* executed on 2/98 states (ground truth positive states).
  Out of the 2 GT positive states, with the current predicates and operators, 2/2 states *satisfy* at least one of its operators' precondition (true positives):
  {'button0:button': {'x': 3.7, 'y': 2.0, 'pressed': 0.0},
   'button1:button': {'x': 3.5, 'y': 4.8, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 2.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 5.1, 'y': 1.3, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 1.2, 'tip_x': 0.7, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 2.3, 'y': 2.0, 'pressed': 0.0},
   'button1:button': {'x': 3.5, 'y': 5.3, 'pressed': 0.0},
   'holder:holder': {'x': 5.4, 'y': 0.7, 'theta': 1.6},
   'robby_hand:hand': {'x': 3.8, 'y': 1.6, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 5.4, 'y': 0.8, 'tip_x': 5.4, 'tip_y': 3.8, 'theta': 1.6, 'held': 0.0}}

Ground option StickPressButton(robby_hand:hand, stick:stick, button1:button) was applied on 98 states and *failed* to executed on 96/98 states (ground truth negative states).
  Out of the 96 GT negative states, with the current predicates and operators, 96/96 states *satisfy* at least one of its operators' precondition (false positives), to list 3:
  {'button0:button': {'x': 3.8, 'y': 1.1, 'pressed': 0.0},
   'button1:button': {'x': 1.7, 'y': 1.2, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 1.7, 'y': 1.2, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 1.1, 'tip_x': 0.7, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 3.8, 'y': 1.1, 'pressed': 0.0},
   'button1:button': {'x': 1.7, 'y': 1.2, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 1.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 5.0, 'y': 2.0, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 1.1, 'tip_x': 0.7, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}

  {'button0:button': {'x': 3.7, 'y': 2.0, 'pressed': 0.0},
   'button1:button': {'x': 3.5, 'y': 4.8, 'pressed': 0.0},
   'holder:holder': {'x': 0.7, 'y': 2.0, 'theta': 1.6},
   'robby_hand:hand': {'x': 5.1, 'y': 1.3, 'theta': 1.6, 'fingers': 1.0},
   'stick:stick': {'x': 0.7, 'y': 1.2, 'tip_x': 0.7, 'tip_y': 4.1, 'theta': 1.6, 'held': 0.0}}


Your objective is to invent all necessary predicates for this domain, so they can be added to the action operators' preconditions or effects to facilitate effective and efficient planning. Define predicates in python blocks as follows:
```python
def classifier(state: State, objects: Sequence[Object]) -> bool:
    # Implement the boolean classifier function here
    
name: str = # Define the predicate name here
types: Sequence[Type] = # Write a list of object types variables exist in the environment here
predicate_name = Predicate(name, types, classifier)
```
More specifically, this means when the invented predicates are added to the preconditions, the states where the ground option fail to execute (GT negative states) should not satisfy any of its ground operators' precondition, while the states where the ground option successfully executed (GT positive states) should satisfy at least one of its operators' precondition.
That is, in future planning, the operators with the invented predicates should help to maximize the number of true positive states while minimizing the number of false positive states.

Ensure that:
- Take the predefined predicate definition for reference;
- Only object-type variables defined in the environment are used for `types`.
- Predicates are distinct and do not introduce new constants.
- When needed, use only predefined methods from the State class such as `get` and `get_objects`;
- The object feature names used in classifier definitions are present in the states and object type instantiations;
- Type declarations in the provided template are strictly followed.