Context: You are an expert AI researcher tasked with inventing task-specific state abstraction predicates for effective and efficient robotic planning.

I will describe the API you should use for writing predicates and the environment the robot is in.
# The API for `NSPredicate` and `State` is:
[STRUCT_DEFINITION]

The environment includes the following object-type variables with features:
[TYPES_IN_ENV]
where `bbox_left`, `bbox_lower`, ..., corresponds to the pixel index of the left, lower boundary of the object bounding box in the image starting from (0, 0) at the bottom left corner of the image.
`pose_x`, `pose_y`, and `pose_z` correspond to the 3d object position in the world frame, so these are not comparable to the bbox values.

The existing predicates are:
[PREDICATES_IN_ENV]

The states the predicates have been evaluated on are:
[LISTED_STATES]

Please implement the following predicates which would have evaluation values that matches the following specification:

[PREDICATE_SPECS]

Implement each predicate in a Python block as follows:
```python
def _<predicate_name>_NSP_holds(state: State, objects: Sequence[Object]) -> bool:
    # Implement the boolean classifier function here
    ...

# Define the predicate name here 
name: str = ... 

# A list of object-type variables for the predicate, using the ones defined in the environment
param_types: Sequence[Type] = ... 
<predicate_name> = NSPredicate(name, param_types, _<predicate_name>_NSP_holds)
```

- When defining classifier functions, it is recommended to first use rules based on object features to identify scenarios where the predicate is *clearly* False (the robot can't be holding anything if its hand is open). Then, if necessary, use the `evaluate_simple_assertion` method to address potential remaining cases. Reference the format of example predicates;
- When writing the proposals, strictly adhere to the following guidlines:
    - Use only object-type variables defined in the environment when defining  `param_types`.
    - Don't use any undefined constants;
    - Don't use object features that are not present in the definition of that object type.
    - Adhere to the type hints in the predicate definition template.
    - Make use of helper functions such as the classifier function in the existing predicates, if they're helpful.
    - Your don't need to import anything.