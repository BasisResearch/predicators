You are an expert AI researcher tasked with inventing task-specific state abstraction predicates for effective and efficient robotic planning.

I will describe the API you should use for writing predicates and the environment the robot is in.
# The API for `Predicate` and `State` is:
```python
class RawState:
    """A class representing the raw visual state of the world.

    Attributes:
    -----------
    labeled_image : Image
        An observation of the state annotated with a unique label for each object.

    Methods:
    --------
    crop_to_objects(self, objects: Collection[Object],
                    left_margin: int = 5, lower_margin: int=10,
                    right_margin: int=10, top_margin: int=5) -> Image:
        Crops the labeled image to only focus on the objects in the input.
    get(self, obj: Object, feature_name: str) -> Any:
        Looks up an object feature by name and returns the feature value.
    get_objects(self, object_type: Type) -> List[Object]:
        Returns objects of the given type.
    evaluate_simple_assertion(assertion: str, image: Image) -> bool:
        Evaluate a simple assertion about an image..
    """
    def crop_to_objects(self, objects: Collection[Object],
                        left_margin: int = 5,
                        lower_margin: int=10, 
                        right_margin: int=10, 
                        top_margin: int=5) -> Image:
        """Crop the labeled_image to only include the specified objects, with
        optional margins around the objects.

        Parameters:
        -----------
        objects : Collection[Object]
            The objects to include in the cropped image.
        left_margin, lower_margin, right_margin, top_margin : int, optional
            The left, lower, right, and top margin to include in the cropped 
            image (default is 5, 10, 10 and 5).

        Returns:
        --------
        Image
            The cropped image.
        Examples:
        ---------
        >>> # An example for predicate NothingNextTo
        >>> def _NothingCloseTo_NSP_holds(state: RawState, objects: Sequence[Object])\
        >>>     -> bool:
        >>>     '''
        >>>     Determine if there is nothing close to the block on the left or
        >>>     right side.
        >>>     '''
        >>>     block, = objects
        >>>     ...
        >>>     # Crop the scene image to the smallest bounding box that include both objects.
        >>>     attention_image = state.crop_to_objects([block], left_margin=20, 
        >>>                         right_margin=20)
        >>>     return state.evaluate_simple_assertion(
        >>>         f"There is nothing close to {block_name} on the left or right side.")
        >>>
        >>> # An example for predicate OnTable
        >>> def _OnTable_NSP_holds(state: RawState, objects:Sequence[Object]) ->\
        >>>         bool:
        >>>     '''Determine if the block is directly resting on the table's 
        >>>     surface.
        >>>     '''
        >>>     apple, = objects
        >>>     apple_name = apple.id_name
        >>>     
        >>>     # Crop the scene image to the smallest bounding box that include both objects.
        >>>     # We know there is only one table in this environment.
        >>>     table = state.get_objects(_table_type)[0]
        >>>     table_name = table.id_name
        >>>     attention_image = state.crop_to_objects([apple, table])

        >>>     return state.evaluate_simple_assertion(
        >>>         f"{apple_name} is directly resting on {table_name}'s surface.",
        >>>         attention_image)
        """

    def get(self, obj: Object, feature_name: str) -> Any:
        """Look up an object feature by name.

        Parameters:
        -----------
        obj : Object
            The object whose feature value is to be retrieved.
        feature_name : str
            The name of the feature to be retrieved.

        Returns:
        --------
        Any
            The value of the specified feature for the given object.
        
        Example:
        ---------
        >>> # An example for predicate WristBent
        >>> _robot_type = Type("robot", ["x", "y", "tilt", "wrist", "gripper"])
        >>> def _GripperOpen_holds(state: State, objects: Sequence[Object]
        >>>                     ) -> bool:
        >>>     robot, = objects
        >>>     return state.get(robot, "gripper") == 1.0
        >>> _WristBent = NSPredicate("GripperOpen", [_robot_type], _WristBent_holds)
        >>>
        >>> # An example for classifying Covers
        >>> def _Covers_NSP_holds(state: State, objects: Sequence[Object]
        >>>                         ) -> bool:
        >>>     '''
        >>>     Determine if the block is covering (directly on top of) the target 
        >>>     region.
        >>>     '''
        >>>     block, target = objects
        >>>
        >>>     # Necessary but not sufficient condition for covering: no part of the 
        >>>     # target region is outside the block.
        >>>     if state.get(target, "bbox_left") < state.get(block, "bbox_left") or\
        >>>        state.get(target, "bbox_right") > state.get(block, "bbox_right"):
        >>>         return False
        >>>     ...
        >>>     return state.evaluate_simple_assertion(...)
        """

    def get_objects(self, object_type: Type) -> List[Object]:
        """Return objects of the given type in the state.

        Parameters:
        -----------
        object_type : Type
            The type of the objects to be retrieved.

        Returns:
        --------
        List[Object]
            A list of objects of the specified type, in the order they are 
            iterated over in the state.

        Examples:
        ---------
        >>> def _robot_hand_above_cup(state: State, cup: Object) -> bool:
        >>>     ...
        >>>
        >>> def _HandNotAboveCup_holds(state: State,
        >>>                            objects: Sequence[Object]) -> bool:
        >>>     for cup in state.get_objects(_cup_type):
        >>>         if _robot_hand_above_cup(state, cup):
        >>>             return False
        >>>     return True
        >>> _HandNotAboveCup = NSPredicate("HandNotAboveCup", [], 
        >>>                              _HandNotAboveCup_holds)
        """

    def evaluate_simple_assertion(self, assertion: str, image: Image) -> bool:
        """A function that takes a simple assertion as a string and an image as
        input, and returns a boolean indicating whether the assertion holds
        true for the image according to the VLM.

        The assertion should be clear, unambiguous, and relatively simple, and 
        the image should have been cropped to only the relavant objects.

        Parameters:
        -----------
        assertion : str
            The assertion to be evaluated. This should be a clear, unambiguous, and 
            relatively simple statement about the image.

        image : Image
            The image for which the assertion is to be evaluated.

        Returns:
        --------
        bool
            True if the VLM determines that the assertion holds true for the image, 
            False otherwise.
        
        Examples:
        ---------
        >>> # An example for predicate Open
        >>> ...
        >>> return state.evaluate_simple_assertion(f"{door_name} is open", attention_image)

        >>> # An example for predicate CupOnTable
        >>> ...
        >>> return state.evaluate_simple_assertion(f"{cup_name} is resting on {shelf_name}", attention_image)

        >>> # An example for predicate CupFilled
        >>> ...
        >>> return state.evaluate_simple_assertion(f"{cup_name} is filled with liquid", attention_image)

        >>> # An example for predicate PluggedIn
        >>> ...
        >>> return state.evaluate_simple_assertion(f"{coffee_machine_name} is plugged into a socket", attention_image)
        """

class NSPredicate:
    """A class representing a predicate, a classifier that characterizes
    properties of states in the context of AI task planning. A predicate is a
    function that takes a state and a sequence of objects as input, and returns
    a boolean value indicating whether a certain property holds for those
    objects in that state.

    Parameters:
    -----------
    name : str
        The name of the predicate.

    types : Sequence[Type]
        The types of the objects that the predicate applies to. This sequence
        length should match the number of objects passed to the classifier. Each
        type corresponds one-to-one with an object in the sequence.

    _classifier : Callable[[State, Sequence[Object]], bool]
        The classifier function for the predicate. It takes a state and a
        sequence of objects as input, and returns a boolean value. The sequence
        of objects should correspond one-to-one with the 'types' attribute. The
        classifier returns True if the predicate holds for those objects in that
        state, and False otherwise.
    """
```

# The Environment
The environment includes the following object-type variables with features:
```python
_robot_type = Type("robot", ["x", "y", "z", "tilt", "wrist", "fingers", "bbox_left", "bbox_right", "bbox_upper", "bbox_lower"])
_jug_type = Type("jug", ["x", "y", "bbox_left", "bbox_right", "bbox_upper", "bbox_lower"])
_cup_type = Type("cup", ["x", "y", "bbox_left", "bbox_right", "bbox_upper", "bbox_lower"])
_machine_type = Type("coffee_machine", ["bbox_left", "bbox_right", "bbox_upper", "bbox_lower"])
_table_type = Type("table", [])
```
where `bbox_left`, `bbox_lower`, ..., corresponds to the pixel index of the left, lower boundry of the object bounding box in the image starting from (0, 0) at the bottom left corner of the image.
`pose_x`, `pose_y` and `pose_z` correspond to the 3d object position in the world frame, so they are not comparable to the bbox values.

The existing set of predicates are:
{'RobotHoldingJug(?x:robot, ?y:jug)', 'RobotNearMachine(?x:robot)', 'CupFilled(?x:cup)', 'JugInMachine(?x:jug, ?y:coffee_machine)'}

Predicate CupFilled(?x) is defined by:
```python
def _CupFilled_NSP_holds(self, state: RawState, objects: Sequence[Object]
                         ) -> bool:
    """Determine if the cup is filled coffee.
    """
    cup, = objects
    cup_name = cup.id_name
    attention_image = state.crop_to_objects([cup])
    return state.evaluate_simple_assertion(
        f"{cup_name} has coffee in it", attention_image)
_CupFilled_NSP = NSPredicate("CupFilled", [_cup_type],
                                          _CupFilled_NSP_holds)
```

The set of options the robot has are:
TurnMachineOn(?x1:robot, ?x0:coffee_machine): Turn the machine on.
PlaceJugInMachine(?x2:robot, ?x1:jug, ?x0:coffee_machine): Place the jug in the machine.
PickJug(?x1:robot, ?x0:jug): Pick up the jug.
Twist(?x1:robot, ?x0:jug): Rotate the jug to the desired rotation.
Pour(?x2:robot, ?x1:jug, ?x0:cup): Pour liquid from the jug to the cup

Utilizing the exisiting predicates, we carefully designed following action operators:
Operator-Op2:
    Parameters: [?x0:coffee_machine, ?x1:robot]
    Preconditions: []
    Add Effects: []
    Delete Effects: []
    Ignore Effects: []
    Option Spec: TurnMachineOn(?x1:robot, ?x0:coffee_machine)
Operator-Op5:
    Parameters: [?x0:jug, ?x1:robot]
    Preconditions: []
    Add Effects: []
    Delete Effects: []
    Ignore Effects: []
    Option Spec: Twist(?x1:robot, ?x0:jug)
Operator-Op4:
    Parameters: [?x0:jug, ?x1:robot]
    Preconditions: [RobotHoldingJug(?x1:robot, ?x0:jug)]
    Add Effects: []
    Delete Effects: [RobotHoldingJug(?x1:robot, ?x0:jug)]
    Ignore Effects: []
    Option Spec: Twist(?x1:robot, ?x0:jug)
Operator-Op3:
    Parameters: [?x0:cup, ?x1:jug, ?x2:robot]
    Preconditions: [RobotHoldingJug(?x2:robot, ?x1:jug)]
    Add Effects: [CupFilled(?x0:cup)]
    Delete Effects: [RobotHoldingJug(?x2:robot, ?x1:jug)]
    Ignore Effects: []
    Option Spec: Pour(?x2:robot, ?x1:jug, ?x0:cup)
Operator-Op1:
    Parameters: [?x0:coffee_machine, ?x1:jug, ?x2:robot]
    Preconditions: [RobotHoldingJug(?x2:robot, ?x1:jug)]
    Add Effects: []
    Delete Effects: [RobotHoldingJug(?x2:robot, ?x1:jug)]
    Ignore Effects: []
    Option Spec: PlaceJugInMachine(?x2:robot, ?x1:jug, ?x0:coffee_machine)
Operator-Op0:
    Parameters: [?x0:jug, ?x1:robot]
    Preconditions: []
    Add Effects: [RobotHoldingJug(?x1:robot, ?x0:jug)]
    Delete Effects: []
    Ignore Effects: []
    Option Spec: PickJug(?x1:robot, ?x0:jug)

The robot tried to excute its options on states that satisfied their preconditions and got the following results:
Option Twist(robot1:robot, jug6:jug) *successfully* executed on the following states (positive states):
  state_0 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 0.8, 'y': 1.4, 'z': 0.6, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.4},
   'table2:table'}
  Previous option: Twist(robot1:robot, jug6:jug)

  state_1 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 1.0, 'y': 1.2, 'z': 0.3, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.1},
   'table2:table'}
  Previous option: PickJug(robot1:robot, jug6:jug)

Option Twist(robot1:robot, jug6:jug) *failed* to executed on the following states (negative states):
  state_34 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 1.0, 'y': 1.3, 'z': 0.3, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.4},
   'table2:table'}
  Previous option: PlaceJugInMachine(robot1:robot, jug6:jug, coffee_machine3:coffee_machine)

Option Pour(robot1:robot, jug6:jug, cup7:cup) *successfully* executed on the following states (positive states):
  state_46 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 1.0, 'y': 1.3, 'z': 0.3, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.1},
   'table2:table'}
  Previous option: PickJug(robot1:robot, jug6:jug)

Option Pour(robot1:robot, jug6:jug, cup7:cup) *failed* to executed on the following states (negative states):
  state_47 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 1.0, 'y': 1.3, 'z': 0.3, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.1},
   'table2:table'}
  Previous option: PickJug(robot1:robot, jug6:jug)

Option TurnMachineOn(robot1:robot, coffee_machine3:coffee_machine) *successfully* executed on the following states (positive states):
  state_34 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 1.0, 'y': 1.3, 'z': 0.3, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.4},
   'table2:table'}
  Previous option: PlaceJugInMachine(robot1:robot, jug6:jug, coffee_machine3:coffee_machine)

Option TurnMachineOn(robot1:robot, coffee_machine3:coffee_machine) *failed* to executed on the following states (negative states):
  state_0 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 0.8, 'y': 1.4, 'z': 0.6, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.4},
   'table2:table'}
  Previous option: Twist(robot1:robot, jug6:jug)

  state_2 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 1.0, 'y': 1.2, 'z': 0.3, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.1},
   'table2:table'}
  Previous option: PickJug(robot1:robot, jug6:jug)

Option PickJug(robot1:robot, jug6:jug) *successfully* executed on the following states (positive states):
  state_0 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 0.8, 'y': 1.4, 'z': 0.6, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.4},
   'table2:table'}
  Previous option: Twist(robot1:robot, jug6:jug)

  state_50 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 1.0, 'y': 1.3, 'z': 0.4, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.4},
   'table2:table'}
  Previous option: TurnMachineOn(robot1:robot, coffee_machine3:coffee_machine)

Option PickJug(robot1:robot, jug6:jug) *failed* to executed on the following states (negative states):
  state_30 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 1.0, 'y': 1.3, 'z': 0.3, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.1},
   'table2:table'}
  Previous option: PickJug(robot1:robot, jug6:jug)

  state_23 with additional info:
  {'coffee_machine3:coffee_machine',
   'cup7:cup',
   'jug6:jug',
   'robot1:robot': {'x': 0.7, 'y': 1.3, 'z': 0.6, 'tilt': 1.6, 'wrist': -1.6, 'fingers': 0.4},
   'table2:table'}
  Previous option: None


Your task is to design predicates--*that are semantically different from the existing predicates*--so that when they are integreated into the preconditions of action operators, the negative states no longer satisfy the operators' precondition, while positive states still satisfy the precondition.

Define each proposal in a Python block as follows:
```python
def <predicate_name>_holds(state: State, objects: Sequence[Object]) -> bool:
    # Implement the boolean classifier function here
    ...

# Define the predicate name here 
name: str = ... 

# A list of object-type variables for the predicate, using the ones defined in the environment
param_types: Sequence[Type] = ... 
<predicate_name> = NSPredicate(name, param_types, <predicate_name>_holds)
```

When writing the proposals, *strictly* adhere to the following guidlines:
- When defining classifier functions, try to 
    1. *first* use rules based on object features to identify scenarios where the predicate is *clearly* False (the robot can't be holding anything if its hand is open). 
    2. Then, use the `evaluate_simple_assertion` method *once* to cover the potential remaining cases. 
Take the format of existing predicates for reference.
- Each proposed predicates are semantically from the existing predicates and each other.
- Don't write out the new operators.
- Make use of helper functions such as the classifier function in the existing predicates and `evaluate_simple_assertion`, if they're helpful. But try not to use `evaluate_simple_assertion` in a loop.