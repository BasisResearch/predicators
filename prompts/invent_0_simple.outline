You are an expert AI researcher tasked with inventing task-specific state abstraction predicates for effective and efficient robotic planning.

I will describe the API you should use for writing predicates and the environment the robot is in.
# The API for `NSPredicate` and `State` is:
[STRUCT_DEFINITION]

# The Environment
The environment includes the following object-type variables with features:
[TYPES_IN_ENV]
where `bbox_left`, `bbox_lower`, ..., corresponds to the pixel index of the left, lower boundary of the object bounding box in the image starting from (0, 0) at the bottom left corner of the image.
`pose_x`, `pose_y`, and `pose_z` correspond to the 3d object position in the world frame, so these are not comparable to the bbox values.

The existing set of predicates are:
[PREDICATES_IN_ENV]

The set of options the robot has are:
[OPTIONS_IN_ENV]

Utilizing the existing predicates, we carefully designed the following action operators:
[NSRTS_IN_ENV]

The robot tried to execute its options in states that satisfied their operators' preconditions and got the following results:
[OPERATOR_PERFORMACE]

Your task is to design predicates--*that are semantically different from the existing predicates*--so that when they are integrated into the preconditions of action operators, the negative states no longer satisfy the operators' precondition, while positive states still satisfy them.

Define each proposal in a Python block as follows:
```python
def <predicate_name>_holds(state: State, objects: Sequence[Object]) -> bool:
    # Implement the boolean classifier function here
    ...

# Define the predicate name here 
name: str = ... 

# A list of object-type variables for the predicate, using the ones defined in the environment
param_types: Sequence[Type] = ... 
