You are an expert roboticist and AI researcher tasked with inventing task-specific state abstraction predicates for effective and efficient robotic planning.

Class definitions for `Predicate` and `State` are:
```python
class RawState:
    """
    A class representing the raw visual state of the world

    Attributes:
    -----------
    state_image : PIL.Image.Image
    obj_mask_dict : Dict[str, Mask]
        A dictionary mapping object names to their corresponding Mask.
    
    Examples:
    ---------
    >>> # An example for predicate Covers
    >>> _block_type = Type("block", ["is_block", "is_target", "width", 
            "pose", "grasp"])
    >>> _target_type = Type("target", ["is_block", "is_target", "width", 
            "pose"])
    >>> block1 = Object("block1", _block_type)
    >>> target1 = Object("target1", _target_type)
    >>> state: PyBulletRenderedState = render_state({
            block1: np.array([1.0, 0.0, 0.1, 0.2, -1.0]), 
            target1: np.array([0.0, 1.0, 0.05, 0.4])})
    >>> ...
    """
    def get_obj_bbox(self, object: Object) -> BoundingBox:
        '''
        Get the bounding box of the object in the state image
        The origin is bottom left corner--(0, 0)
        '''

    def crop_to_objects(self, objects: Sequence[Object],
                        left_margin: int = 5,
                        lower_margin: int=10, 
                        right_margin: int=10, 
                        top_margin: int=5) -> Image:


class NSPredicate:
    """
    A class representing a predicate (a lifted classifier over states) in the 
    context of AI task planning.
    A predicate is mainly a function that describes a property or characteristic 
    of states. The function takes a state and a sequence of objects as input, 
    and returns a boolean value indicating whether the property holds for those 
    objects in that state.

    Attributes:
    -----------
    name : str
        The name of the predicate.

    types : Sequence[Type]
        The types of the objects that the predicate applies to. This sequence 
        should have the same length as the sequence of objects passed to the 
        classifier.

    _classifier : Callable[[State, Sequence[Object]], bool]
        The classifier function for the predicate. This function takes a state 
        and a sequence of objects as input, and returns a boolean value. The 
        objects in the sequence should correspond one-to-one with the types in 
        the 'types' attribute. The classifier should return True if the 
        predicate holds for those objects in that state, and False otherwise.
    """    
    name: str
    types: Sequence[Type]
    # The classifier takes in a complete state and a sequence of objects
    # representing the arguments. These objects should be the only ones
    # treated "specially" by the classifier.
    _classifier:  Callable[[RawState, Sequence[Object]], bool]

def evaluate_simple_assertion(assertion:str, image:Image) -> bool:
    """A simple helper function for evaluating assertions on images....
    """
```


The environment includes the following object-type variables:
```python

    _block_type = Type("block", [])
    _robot_type = Type("robot", ["pose_x", "pose_y", "pose_z", "fingers"])
    _table_type = Type("table", [])
```


The initial set of predicates used to describe goals includes:
{'On(?x, ?y)', 'OnTable(?x)'}

Predicate On(?x, ?y) is defined by
```python
def _On_holds(self, state: State, objects: Sequence[Object]) -> bool:
    block1, block2 = objects
    if state.get(block1, "held") >= held_tol or \
       state.get(block2, "held") >= held_tol:
        return False
    x1 = state.get(block1, "pose_x")
    y1 = state.get(block1, "pose_y")
    z1 = state.get(block1, "pose_z")
    x2 = state.get(block2, "pose_x")
    y2 = state.get(block2, "pose_y")
    z2 = state.get(block2, "pose_z")
    return np.allclose([x1, y1, z1], [x2, y2, z2 + _block_size],
                       atol=on_tol)
_On_NSP = NSPredicate("On", [_block_type, _block_type],
                            _MemoizedClassifier(_On_NSP_holds)
```

Predicate OnTable(?x) is defined by
```python
def _OnTable_holds(self, state: State, objects: Sequence[Object]) -> bool:
    block, = objects
    z = state.get(block, "pose_z")
    desired_z = table_height + _block_size * 0.5
    return (state.get(block, "held") < held_tol) and \
        (desired_z-on_tol < z < desired_z+on_tol)
_OnTable_NSP = NSPredicate("OnTable", [_block_type],
                            _MemoizedClassifier(_OnTable_NSP_holds)
```


The set of parameterized options includes:
Pick(?robot:robot, ?block:block)
PutOnTable(?robot:robot)
Stack(?robot:robot, ?otherblock:block)

The existing abstract action operators utilizing these options are:
Unstack:
    Parameters: [?block:block, ?otherblock:block, ?robot:robot]
    Preconditions: [On(?block:block, ?otherblock:block)]
    Add Effects: []
    Delete Effects: [On(?block:block, ?otherblock:block)]
    Ignore Effects: []
    Option Spec: Pick(?robot:robot, ?block:block)
PutOnTable:
    Parameters: [?block:block, ?robot:robot]
    Preconditions: []
    Add Effects: [OnTable(?block:block)]
    Delete Effects: []
    Ignore Effects: []
    Option Spec: PutOnTable(?robot:robot)
PickFromTable:
    Parameters: [?block:block, ?robot:robot]
    Preconditions: [OnTable(?block:block)]
    Add Effects: []
    Delete Effects: [OnTable(?block:block)]
    Ignore Effects: []
    Option Spec: Pick(?robot:robot, ?block:block)
Stack:
    Parameters: [?block:block, ?otherblock:block, ?robot:robot]
    Preconditions: []
    Add Effects: [On(?block:block, ?otherblock:block)]
    Delete Effects: []
    Ignore Effects: []
    Option Spec: Stack(?robot:robot, ?otherblock:block)

The agent attempted the training tasks by bilevel planning (first plan with the ground action operators then execute its corresponding ground options), collecting these results:
Ground option Stack(robby:robot, block1:block) was applied on 1 states and *failed* to executed on 1/1 states (ground truth negative states).
  Out of the 1 GT negative states, with the current predicates and operators, 1/1 states *satisfy* at least one of its operators' precondition (false positives):
pybullet_blocks_Stack(robby:robot, block1:block)_fp_0.png

Ground option Stack(robby:robot, block0:block) was applied on 1 states and *failed* to executed on 1/1 states (ground truth negative states).
  Out of the 1 GT negative states, with the current predicates and operators, 1/1 states *satisfy* at least one of its operators' precondition (false positives):
pybullet_blocks_Stack(robby:robot, block0:block)_fp_0.png

Ground option Stack(robby:robot, block3:block) was applied on 2 states and *failed* to executed on 2/2 states (ground truth negative states).
  Out of the 2 GT negative states, with the current predicates and operators, 2/2 states *satisfy* at least one of its operators' precondition (false positives):
pybullet_blocks_Stack(robby:robot, block3:block)_fp_0.png

Ground option PutOnTable(robby:robot) was applied on 1 states and *failed* to executed on 1/1 states (ground truth negative states).
  Out of the 1 GT negative states, with the current predicates and operators, 1/1 states *satisfy* at least one of its operators' precondition (false positives):
pybullet_blocks_PutOnTable(robby:robot)_fp_0.png


Your objective is to invent all necessary predicates for this domain, so they can be added to the action operators' preconditions or effects to facilitate effective and efficient planning. Define predicates in python blocks as follows:
```python
def classifier(state: State, objects: Sequence[Object]) -> bool:
    # Implement the boolean classifier function here
    
name: str = # Define the predicate name here
types: Sequence[Type] = # Write a list of object types variables exist in the environment here
predicate_name = Predicate(name, types, classifier)
```
More specifically, this means when the invented predicates are added to the preconditions, the states where the ground option fail to execute (GT negative states) should not satisfy any of its ground operators' precondition, while the states where the ground option successfully executed (GT positive states) should satisfy at least one of its operators' precondition.
That is, in future planning, the operators with the invented predicates should help to maximize the number of true positive and negative states while minimizing the number of false positive and negative states.

Ensure that:
- Take the predefined predicate definition for reference;
- Only object-type variables defined in the environment are used for `types`.
- Predicates are distinct and do not introduce new constants.
- When needed, use only predefined methods from the State class such as `get` and `get_objects`;
- The object feature names used in classifier definitions are present in the states and object type instantiations;
- Type declarations in the provided template are strictly followed.