Please transform the following `NSPredicate`s to `ConceptPredicate`s.
**Task Overview:**
Transform the predicate classifiers to use an abstract state represented by a set of `GroundAtom` objects (`atoms: Set[GroundAtom]`) instead of a `State` object (`state: State`).
The transformed predicates should be instances of `ConceptPredicate` instead of `NSPredicate` and their classifier functions should have the signature:
`def _<predicate_name>_CP_holds(atoms: Set[GroundAtom], objects: Sequence[Object]) -> bool:` instead of `_<predicate_name>_NSP_holds(state: State, objects: Sequence[Object]) -> bool:`

**Existing Predicates**
* Primitive Predicates:
{PRIMITIVE_PREDICATES}

* Concept (Derived) Predicates:
{CONCEPT_PREDICATES}

**Untransformed Predicates:**
{UNTRANSFORMED_PREDICATES}

**Response Format:**
In your response, write each transformed predicate in a Python block formatted as follows:
```python
# Define the classifier function
def _<predicate_name>_CP_holds(atoms: Set[GroundAtom], objects: Sequence[Object]) -> bool:
    # Implement the boolean classifier function here
    ...

# Define the predicate name here 
name: str = ... 

# A list of object-type variables for the predicate, using the ones defined in the environment
param_types: Sequence[Type] = ... 

# Instantiate the predicate
<predicate_name> = ConceptPredicate(name, param_types, _<predicate_name>_CP_holds)
```


### Example 1: Transforming the `Clear` Predicate
The untransformed NSPredicate is:
```python
def _Clear_NSP_holds(state: State, objects: Sequence[Object]) -> bool:
    block, = objects
    for other_block in state.get_objects(_block_type):
        if _DirectlyOn_NSP_holds(state, [other_block, block]):
            return False
    return True

name: str = "Clear"
param_types = [_block_type]
Clear = NSPredicate(name, param_types, _Clear_NSP_holds)
```
The transformed ConceptPredicate is:
```python
def _Clear_CP_holds(atoms: Set[GroundAtom], objects: Sequence[Object]) -> bool:
    block, = objects
    for atom in atoms:
        if atom.predicate == DirectlyOn and atom.objects[1] == block:
            return False
    return True

name: str = "Clear"
param_types = [_block_type]
Clear = ConceptPredicate(name, param_types, _Clear_CP_holds)
```

### Example 2: Transforming the `Holding` Predicate
The untransformed NSPredicate is:
```python
def _Holding_NSP_holds(state: State, objects: Sequence[Object]) -> bool:
    block, = objects
    for other_block in state.get_objects(_block_type):
        if _DirectlyOn_NSP_holds(state, [block, other_block]):
            return False
        if _DirectlyOnTable_NSP_holds(state, [block]):
            return False
    return True

name: str = "Holding"
param_types = [_block_type]
Holding = NSPredicate(name, param_types, _Holding_NSP_holds)
```

The transformed ConceptPredicate is:
```python
def _Holding_CP_holds(atoms: Set[GroundAtom], objects: Sequence[Object]) -> bool:
    block, = objects
    for atom in atoms:
        if atom.predicate == DirectlyOn and atom.objects[0] == block:
            return False
        if atom.predicate == DirectlyOnTable and atom.objects[0] == block:
            return False
    return True

name: str = "Holding"
param_types = [_block_type]
Holding = ConceptPredicate(name, param_types, _Holding_CP_holds)
```

**Important Notes:**
- Each `GroundAtom` object has the attributes `predicate: Predicate` and `objects: Sequence[Object]`, which you can use to identify the predicate and its associated objects in the ground atom.
- To check the truth value of ground atoms made from existing **primitive predicates** (such as for `DirectlyOn` as in `if _DirectlyOn_NSP_holds(state, [other_block, block])` in the example above), you should **iterate over and inspect** the `GroundAtom`s in the `atoms` set, rather than calling their classifier functions (e.g., `_DirectlyOn_NSP_holds`).
- Conversely, to check the truth value of ground atoms made from existing **concept (derived) predicates**, you should **use their classifier functions** in the form `_<predicate_name>_CP_holds`, which may involve recursive calls of the function youâ€™re defining